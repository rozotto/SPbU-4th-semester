# Вариант 17
import numpy as np

exact_answer = 2308.287524452809436132810373422088766896
methodological_error = 5.55023


def f(x):
    return 6 * np.cos(1.5 * x) * np.exp(5 * x / 3) + 2 * np.sin(0.5 * x) * np.exp(-1.3 * x) + 5.4 * x


def p(x, a=3.5, b=3.7, alpha=2 / 3, beta=0):
    return (x - a) ** (-alpha) * (b - x) ** (-beta)


def IQF_NewtonKots(a=3.5, b=3.7):
    # задаем узлы квадратурной формулы (9)
    x1 = a
    x2 = (a + b) / 2
    x3 = b
    x = np.array([x1, x2, x3])

    # вычисляем моменты весовой функции (12)
    m0 = (3 * (b - 7 / 2) ** (1 / 3)) - (3 * (a - 7 / 2) ** (1 / 3))
    m1 = (3 / 4 * (b - 7 / 2) ** (1 / 3) * (b + 3 * 7 / 2)) - (3 / 4 * (a - 7 / 2) ** (1 / 3) * (a + 3 * 7 / 2))
    m2 = (1 / 14 * (b - 7 / 2) ** (1 / 3) * (6 * b ** 2 + 9 * 7 / 2 * b + 27 * (7 / 2) ** 2)) - (1 / 14 * (a - 7 / 2) ** (1 / 3) * (6 * a ** 2 + 9 * 7 / 2 * a + 27 * (7 / 2) ** 2))
    mu = np.array([m0, m1, m2])

    # решаем СЛАУ (13)
    powers = np.arange(3)[:, None]
    A = x ** powers
    A = np.linalg.solve(A, mu)
    A1, A2, A3 = A

    # записываем все в квадратурную формулу (9)
    return A1 * f(x1) + A2 * f(x2) + A3 * f(x3)


# формула (36)
def Aitken(S, k):
    return -np.log(abs(S[-1] - S[-2]) / abs(S[-2] - S[-3])) / np.log(k)


# формула (35)
def Richardson(S, H, r, m):
    A = -1 * np.ones((r + 1, r + 1))
    for i in range(r):
        A[:, i] = H ** (i + m)
    C = np.linalg.solve(A, -S)
    return C


def Runge(S, H, a=3.5, b=3.7, eps=1e-6):
    # снова посчитаем по формуле (36)
    m = Aitken(S, 2)

    # найдем приближенные представления погрешностей по формулам (31-32)
    R_h1 = (S[1] - S[0]) / (1 - 2 ** (-m))
    R_h2 = (S[1] - S[0]) / (2 ** m - 1)

    # найдем приблизительный оптимальный шаг разбиения (34)
    h1_opt = (H[0] * (eps / abs(R_h1)) ** (1 / m)) * 0.95
    h2_opt = (H[1] * (eps / abs(R_h2)) ** (1 / m)) * 0.95

    # итоговый оптимальный шаг из (Замечание 4)
    k1_opt = int(np.ceil((b - a) / h1_opt))
    k2_opt = int(np.ceil((b - a) / h2_opt))

    return k1_opt, k2_opt


def SQF_NewtonKots(k=1, a=3.5, b=3.7, eps=1e-6):
    # задаем списки значений интегралов и шагов
    S = np.array([])
    H = np.array([])

    # задаем счетчик итераций и начальное значение ошибки
    cnt = 0
    error = 10 ** 10
    while error > eps:
        cnt += 1

        # смотрим "Пример построения СКФ Ньютона — Котса" на 12 стр методички
        h = (b - a) / k
        sum = 0
        for i in range(k):
            start = a + i * h
            end = start + h

            # тот же самый пример, но уже чуть пониже, до пункта (25)
            sum += IQF_NewtonKots(start, end)
        S = np.append(S, sum)
        H = np.append(H, h)

        # процесс Эйткена, формула (36), задаем начальное значение, так как для метода нужны хотя бы 3 Sh
        r = len(S) - 1
        if r >= 2:
            m = Aitken(S, k)
        else:
            m = r

        # оцениваем погрешность методом Ричардсона по формуле (35)
        C = Richardson(S, H, r, m)

        # обновляем значение ошибки, где если r == 0, то в методе Ричардсона получаем нулевую матрицу,
        # а соответственно и нулевые С, тогда ошибки как бы вовсе нет
        error = abs(exact_answer - S[r]) if r == 0 else abs(C[r] - S[r])
        print(f'Шаг {k}, Степень по Эйткену: {m}, Текущая точность: {error}, Значение по Ричардсону: {C[r]}')
        k *= 4
    return S, H, cnt


IQF_answer = IQF_NewtonKots()
print('ИКФ с весовой функцией методом Ньютона-Котса')
print('Наше решение:', IQF_answer)
print('Методическая погрешность:', methodological_error)
print('Точная погрешность:', exact_answer - IQF_answer)
print()


S, H, cnt = SQF_NewtonKots()
print('CКФ с весовой функцией методом Ньютона-Котса')
print('Наше решение:', S[-1])
print(f'Мы его получили за {cnt} итераций')
print('Точная погрешность:', abs(exact_answer - S[-1]))
print()

k_opt = min(Runge(S, H))
print('Оптимальное количество шагов для метода Ньютона-Котса:', k_opt)
S, _, cnt = SQF_NewtonKots(k_opt)
print('Наше решение:', S[-1])
print(f'Мы его получили за {cnt} итераций')
print('Точная погрешность:', abs(exact_answer - S[-1]))
print()


def IQF_Gauss(a=3.5, b=3.7):
    # вычисляем моменты весовой функции (18)
    m0 = (3 * (b - 7 / 2) ** (1 / 3)) - (3 * (a - 7 / 2) ** (1 / 3))
    m1 = (3 / 4 * (b - 7 / 2) ** (1 / 3) * (b + 3 * 7 / 2)) - (3 / 4 * (a - 7 / 2) ** (1 / 3) * (a + 3 * 7 / 2))
    m2 = (1 / 14 * (b - 7 / 2) ** (1 / 3) * (6 * b ** 2 + 9 * 7 / 2 * b + 27 * (7 / 2) ** 2)) - (1 / 14 * (a - 7 / 2) ** (1 / 3) * (6 * a ** 2 + 9 * 7 / 2 * a + 27 * (7 / 2) ** 2))
    m3 = (1 / 140 * (b - 7 / 2) ** (1 / 3) * (42 * b ** 3 + 54 * 7 / 2 * b ** 2 + 81 * (7 / 2) ** 2 * b + 243 * (7 / 2) ** 3)) - (1 / 140 * (a - 7 / 2) ** (1 / 3) * (42 * a ** 3 + 54 * 7 / 2 * a ** 2 + 81 * (7 / 2) ** 2 * a + 243 * (7 / 2) ** 3))
    m4 = (1 / 455 * (b - 7 / 2) ** (1 / 3) * (105 * b ** 4 + 126 * 7 / 2 * b ** 3 + 162 * (7 / 2) ** 2 * b ** 2 + 243 * (7 / 2) ** 3 * b + 729 * (7 / 2) ** 4)) - (1 / 455 * (a - 7 / 2) ** (1 / 3) * (105 * a ** 4 + 126 * 7 / 2 * a ** 3 + 162 * (7 / 2) ** 2 * a ** 2 + 243 * (7 / 2) ** 3 * a + 729 * (7 / 2) ** 4))
    m5 = (1 / 1456 * (b - 7 / 2) ** (1 / 3) * (273 * b ** 5 + 315 * 7 / 2 * b ** 4 + 378 * (7 / 2) ** 2 * b ** 3 + 486 * (7 / 2) ** 3 * b ** 2 + 729 * (7 / 2) ** 4 * b + 2187 * (7 / 2) ** 5)) - (1 / 1456 * (a - 7 / 2) ** (1 / 3) * (273 * a ** 5 + 315 * 7 / 2 * a ** 4 + 378 * (7 / 2) ** 2 * a ** 3 + 486 * (7 / 2) ** 3 * a ** 2 + 729 * (7 / 2) ** 4 * a + 2187 * (7 / 2) ** 5))

    # решаем СЛАУ (19)
    mu = - 1 * np.array([m3, m4, m5])
    M = np.array([[m0, m1, m2], [m1, m2, m3], [m2, m3, m4]])
    A = np.flip(np.linalg.solve(M, mu))

    # находим узлы x_j как корни узлового многочлена (20)
    w = np.array([1])
    w = np.append(w, A)
    x = np.roots(w)

    # решаем СЛАУ (21)
    powers = np.arange(3)[:, None]
    A = x ** powers
    mu = np.array([m0, m1, m2])
    A = np.linalg.solve(A, mu)
    A_1, A_2, A_3 = A
    x_1, x_2, x_3 = x

    # записываем все в квадратурную формулу (9)
    return A_1 * f(x_1) + A_2 * f(x_2) + A_3 * f(x_3)


def SQF_Gauss(k=1, a=3.5, b=3.7, eps=1e-6):
    # задаем списки значений интегралов и шагов
    S = np.array([])
    H = np.array([])

    # задаем счетчик итераций и начальное значение ошибки
    cnt = 0
    error = 10 ** 10
    while error > eps:
        cnt += 1

        # смотрим "Пример построения СКФ Ньютона — Котса" на 12 стр методички
        h = (b - a) / k
        sum = 0
        for i in range(k):
            start = a + i * h
            end = start + h

            # тот же самый пример, но уже чуть пониже, до пункта (25)
            sum += IQF_Gauss(start, end)
        S = np.append(S, sum)
        H = np.append(H, h)

        # процесс Эйткена, формула (36), задаем начальное значение, так как для метода нужны хотя бы 3 Sh
        r = len(S) - 1
        if r >= 2:
            m = Aitken(S, k)
        else:
            m = r

        # оцениваем погрешность методом Ричардсона по формуле (35)
        C = Richardson(S, H, r, m)

        # обновляем значение ошибки, где если r == 0, то в методе Ричардсона получаем нулевую матрицу,
        # а соответственно и нулевые С, тогда ошибки как бы вовсе нет
        error = abs(exact_answer - S[r]) if r == 0 else abs(C[r] - S[r])
        print(f'Шаг {k}, Степень по Эйткену: {m}, Текущая точность: {error}, Значение по Ричардсону: {C[r]}')
        k *= 2
    return S, H, cnt


IQF_answer = IQF_Gauss()
print('ИКФ с весовой функцией методом Гаусса')
print('Наше решение:', IQF_answer)
print('Методическая погрешность:', methodological_error)
print('Точная погрешность:', abs(exact_answer - IQF_answer))
print()

S, H, cnt = SQF_Gauss()
print('CКФ с весовой функцией методом Гаусса')
print('Наше решение:', S[-1])
print(f'Мы его получили за {cnt} итераций')
print('Точная погрешность:', abs(exact_answer - S[-1]))
print()

k_opt = min(Runge(S, H))
print('Оптимальное количество шагов для метода Гаусса:', k_opt)
S, _, cnt = SQF_Gauss(k_opt)
print('Наше решение:', S[-1])
print(f'Мы его получили за {cnt} итераций')
print('Точная погрешность:', abs(exact_answer - S[-1]))
print()